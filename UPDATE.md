## 踩坑记录
> 这是我学习完vue系列后做的第一个demo，看了大概4天的文档和各种文章，就开始做的，虽然很多概念跟react相似，但由于模板语法不
同，罪人网友都说vue比react容易，都说JSX语法难懂，但不知道怎的我觉得JSX的语法更加清晰，感觉vue反而复杂一点。有的地方还不是
很熟练，因此虽然逻辑跟上一个demo大同小异，但做的时间还是有点长，下面记录下过程中遇到的问题和解决办法，总结一下。

##### 1.11
```
    上一个demo使用less的时候都没有真正地使用mixin和全局变量，都是像平常写css一样，最多也就用到嵌套而已。这次使用element，
顺便可以学习scss，vue-cli很方便，创建项目时就直接可以部署好scss的环境。然后当我想使用全局变量时，按照文档的介绍，需要在
webpack去添加，但问题是我没有找到文档中所说的webpack的配置文档。后来才知道vue-cli3更改为编辑vue.config.js去设定，在这里
耽误的时间较长。
    
    之后就轮到使用element的问题了，由于想自定义样式，尝试按文档自定义主题部分的命令行方法去生成主题，但总是提示需要先安
装element-theme-chalk，但我已经安装了，依然不行，无奈之下自行创建scss文件，引入element的变量表，然后做变量覆盖。然后当我
保存后发现报错说找不到文件，我以为我的vue.config.js配置错误了，在网上查了好久，后来才发现其实修改vue conifg文件后需要重新
运行yarn run serve，否则vue-loader会出现错误。。。

    之后第一次使用scss的mixin和变量，感觉十分便捷，虽然很多高级用法还是没有熟练，但确实效率高了很多，后悔没有早点用。之后
时间都基本花在调整样式上。

    过程有个问题，就是element的table组件，它的背景色，我直接在.el-table和.el-table-column设置，没有反应，然后打开控制台，
直接设置.el-table__row的样式，还是有问题的。具体情况是，我想将背景设置为半透明，但无论怎么设置，表格总会有一个白色底色，
我尝试将我在控制台看到的所有table下的class都设置样式，还是改变不到。然后想到是不是默认变量导致，于是把table相关的变量全部
覆盖了一遍，无效。于是网上查了一下，好像没有人提起。翻查文档，看到table有几个属性，可以更改样式，但试了下添加样式对象到
row-style，是不行的没效果。在上面耗了好久，甚至一度想放弃表格，想用列表代替。后来把心一横，试一下将有关更高组件样式的属
性都赋值上样式，同时css也设置好样式，结果居然起效了。。。后来经过调试，发现要更改背景为透明，需要同时在header-cell-style、
header-row-style、row-style三个属性都要放入同样的样式对象，然后css里.el-table类也必须设置同样的样式才能成功更改到这个背景
色。不知道是我方向错了没发现更好的办法，还是table组件本身是这样的，感觉好麻烦啊哈哈哈。
```

##### 1.12
```
    由于开始项目前没有好好规划整个项目，结果基本都是写几段代码就需要调整项目结构，这是个问题，以后得先想好整个结构再开
始，不然浪费的时间太多了。vuex的概念跟之前看的dva很接近，因此上手难度不是太大。

    有个问题是组织Store的结构和一些细节上自己绕了圈子，本身因为传递vuex中的数据到组件中要用mapXXXX系列函数，action和muta-
tion，也可以用$store.commit/dispatch去完成。由于用mapXXX函数输入的是字符串，因此我想是不是全部改成常量去存储会好一点。意思
是将state、getters、action和mutation的key全部用常量代替，方便在特定文件调用，而且更改时也方便，只需要更改一处就可以应用到
整个app，但后来我后悔了，全部都用常量代替，一开始数据不多时还好，后面多起来就可读性和操作都不太好，还增加了代码量。

    其实这是我想太多了，首先因为用了react的思维去想事情，想着store的数据直接传递会不会让store的结构和组件形成强耦合，但其
实这个并不会。毕竟vuex传递到组件的state有多种方式，不是react-redux的mapStateToProp那样，例如想传递状态id时要直接传入state.id
，这样的结构形成强耦合，要解耦还需要另外封装一个如getIdFromState的接口，不把结构暴露，让组件不依赖state树结构。但其实vuex
已经考虑到，因此直接输入字符串就可以调用相应的属性（命名空间module除外），因此我又把自己弄好的常量又删掉，把所有用到这些
常量的文件都改回直接调用字符串。
```

##### 1.13
```
    写好几个组件之后回看一下，博文列表和详情页读取数据的逻辑是一样的，可以复用，于是我写了一个高阶组件，复用的主要是生命
周期函数和导航守卫函数，将子组件插入到高阶组件的slot中达成复用。但有个问题是，即使我写了beforeRouteUpdate函数，但当导航到
不同的博文列表页时没有调用，本身这个函数放在PostList组件调用时时没有问题，但放到高阶组件就不行。而根据文档的提示，这个方
法只有路由变更但组件复用时才会调用，路由方面确实是变更了，高阶组件也应该是复用的，而beforeRouteEnter和beforeRouteLeave两
个导航守卫方法都是可以调用的，因此搞不懂，难道高阶组件的没有真正的被复用？于是用了watch方法，监听$route的路径去触发。

    其实这里我也犯了一个惯性react思维的错误，vue提供的slot其实更多的是想复用ui的逻辑，如果是生命周期或者其他的一些方法和
数据，其实可以用到mixins去完成。于是我把高阶组件的数据调整了一下，做成了mixins，直接混入到子组件中，这个方法能让之前说的
beforeRouteUpdate函数被调用，因此我估计没有之前触发钩子是出在高阶组件身上，可能是组件没有真正的被复用。

    之后在添加过渡特效时遇到了情况，用transition包裹的router-view，只有在不同组件间切换才有效果，复用的组件却没有动画，
很明显这是组件复用没有重新加载导致的问题。在官方文档中过渡特效那一部分，关于需要给复用组件添加特效的话是需要给组件添加上
key值去让它判断这是一个不同的组件，然后展示特效。于是我在路由表中需要用到的所有组件都添加了key值，不出所料没有效果。理论
上操作应该是对的，一开始我以为因为我给的key值是字符串所以不起效，于是将route.path作为key值，这个肯定是唯一的了，但依然不
行。然后在vue-router文档中关于路由过渡那一部分，有介绍到可以用watch $route的方法或者导航守卫钩子去完成，但我感觉太麻烦了，
绑定key应该就能做到的。经过一番尝试后，终于知道在router-view上绑定key值，就能实现过场特效了。之后特意翻查了下router-view
这个组件，官方的介绍说其实这个就是一个动态组件，因此像动态组件绑定特效一样就行了，因为component本身已经用is动态绑定了一个
表示当前组件的值，因此只需要简单包裹就能实现特效，而router-view因为没有添加绑定，因此只要在上面给定一个表示组件的值就可以，
这种情况下最好的办法就是添加route的值了。
```

##### 1.14
```
    调整了一下面包屑导航条的项目，将最后一项动态调整为文章标题，然后再测试时，留意到每次切换组件都会进行两次的数据请求。
仔细看了下mixins的部分后找到原因。因为昨天在处理过渡特效时，在router-view添加了key值，这样导致每个组件都是重新加载的，而
我mixin的部分是包含一个created钩子和一个beforeRouteUpdate的导航守卫，因此每次切换页面都会进行两次请求，在删掉导航守卫后就
解决了。
    
    之后完成了分页功能。这个功能是第一次做，在上一个demo中的分页功能，因为antd的menu组件本身自带pagination属性，简单的添
就能使用。本身以为element也是这样，毕竟antd和element的文档也没有详细介绍这个组件。于是我找了form和table组件看看有没有相关
设定，发现是没有的。后来网上查了下，才知道要自己写方法去过滤的，好吧。。。其实原理很简单，就是输入pageSize和current-page
这两个参数，然后在获取到数据列表的长度后赋值到total属性，根据这三个参数去计算每页显示的条目，将过滤后的数组绑定给表格或
列表就可以了。之后将这部分逻辑做成一个mixin文件，可以服用到博文列表和评论列表组件中。
```

##### 1.15
```
    在处理列表组件的过渡特效时，发现会出现文档说的生硬过渡的情况。文档中是推荐用v-move完成，但我本身是用element组件自带
特效，v-move这个方法好像没有用。于是我添加了leave-active-class，设置离开组件时样式为{opacity: 0, position: absolute}，
算是没有问题了，但这样做的话，特效的过渡有点丑,还是会有点抖动。后来在leave-active-class里设置了变透明的过渡时间为0s，即
添加transition: opacity 0s，这样就没有了退场时的抖动，看上去自然一点。

    之后添加了富文本功能。一开始是选择mavon-editor的，但无奈那个背景色怎样都改不了，于是放弃了改用Vue2Editor，虽然功能比
前者少了点，但基本能满足要求了。由于想复用这个编辑器组件，因此不打算将状态放到state树上，把状态保存在组件里面，这样更方便。
然后就写了一个发布文章、评论的action。之前使用json-server的时候没有仔细看文档，很多filter方法没有用上。这次了解到了几个很
有用的方法，如sort、page、slice方法，可以简化很多操作。上一个demo在发布时，因为不知道这几种查询方式，在获取现有id去生成新
id方面做得比较复杂，要在数据库做一个id池然后在saga里又有进行几次请求和更改。掌握这个方法后，id方面我现在是直接查询所需数据
数组，将其倒序排列后并将第一个返回，返回的对象中的id就是目前最新的id了，跟上一个demo对比，请求次数减少了两次，之后有时间
会对旧demo进行优化。
```

##### 1.16
```
    由于博客展示的部分基本完成，现在想把管理的部分区分开来，把发表博文和管理评论之类的功能整合到去后台，后台地址不展示在
博客的展示页面上。但因为很多逻辑例如发表文章和获取文章，都是跟前台部分很接近的，唯一不同的就是ui页面，于是在想能不能使用
mixins混入生命周期的同时，把这些混入的数据根据不同条件，通过slot传递给不同ui组件。
    
    slot的slot-scope之前不是很了解，以为只是在组件执行v-for时想自定义子组件的样式才使用，但其实除了这个功能外，还能像我
所想那样，调用组件时获取到组件中的，然后在插入子组件时，把先前获取的数据在按需绑定给子组件。虽然现在说着很简单，但我因为
不熟悉，文档的例子也不多，自己尝试了好久，看了几篇文章，才彻底搞清楚这个用法。之后就把原先的获取数据的mixin合并到这个组
件中。
    
    现在调用的思路是，调用这个高阶组件时给一个target属性，去确定获取的内容，通过prop传递给高阶组件，然后高阶组件根据这个
prop去计算应该获取什么数据，并返回。过程中发现，我在data、methods和computed里使用的这个prop是undefined的，记得文档之前说
过类似的情况，于是翻查了一下，知道了因为判断prop是在组件实例创建之前进行验证的，因此判断prop时时获取不到data的属性，但问
题是初始化prop比初始化data要早，为什么我获取不到呢？于是我在生命周期里查看，发现beforeCreate时，prop是undefined的，只有在
组件created后，才能获取到prop的值，于是我试过在computed中使用this.$nexttick方法去看看能不能在下一个循环周期去获取prop，但
发现还是不行，这里实在想不明白，无奈唯有把部分要判断的逻辑放到created后再dispatch一个action去判断。
```