## 踩坑记录
> 这是我学习完vue系列后做的第一个demo，看了大概4天的文档和各种文章，就开始做的，虽然很多概念跟react相似，但由于模板语法不
同，罪人网友都说vue比react容易，都说JSX语法难懂，但不知道怎的我觉得JSX的语法更加清晰，感觉vue反而复杂一点。有的地方还不是
很熟练，因此虽然逻辑跟上一个demo大同小异，但做的时间还是有点长，下面记录下过程中遇到的问题和解决办法，总结一下。

##### 1.11
```
    上一个demo使用less的时候都没有真正地使用mixin和全局变量，都是像平常写css一样，最多也就用到嵌套而已。这次使用element，
顺便可以学习scss，vue-cli很方便，创建项目时就直接可以部署好scss的环境。然后当我想使用全局变量时，按照文档的介绍，需要在
webpack去添加，但问题是我没有找到文档中所说的webpack的配置文档。后来才知道vue-cli3更改为编辑vue.config.js去设定，在这里
耽误的时间较长。
    
    之后就轮到使用element的问题了，由于想自定义样式，尝试按文档自定义主题部分的命令行方法去生成主题，但总是提示需要先安
装element-theme-chalk，但我已经安装了，依然不行，无奈之下自行创建scss文件，引入element的变量表，然后做变量覆盖。然后当我
保存后发现报错说找不到文件，我以为我的vue.config.js配置错误了，在网上查了好久，后来才发现其实修改vue conifg文件后需要重新
运行yarn run serve，否则vue-loader会出现错误。。。

    之后第一次使用scss的mixin和变量，感觉十分便捷，虽然很多高级用法还是没有熟练，但确实效率高了很多，后悔没有早点用。之后
时间都基本花在调整样式上。

    过程有个问题，就是element的table组件，它的背景色，我直接在.el-table和.el-table-column设置，没有反应，然后打开控制台，
直接设置.el-table__row的样式，还是有问题的。具体情况是，我想将背景设置为半透明，但无论怎么设置，表格总会有一个白色底色，
我尝试将我在控制台看到的所有table下的class都设置样式，还是改变不到。然后想到是不是默认变量导致，于是把table相关的变量全部
覆盖了一遍，无效。于是网上查了一下，好像没有人提起。翻查文档，看到table有几个属性，可以更改样式，但试了下添加样式对象到
row-style，是不行的没效果。在上面耗了好久，甚至一度想放弃表格，想用列表代替。后来把心一横，试一下将有关更高组件样式的属
性都赋值上样式，同时css也设置好样式，结果居然起效了。。。后来经过调试，发现要更改背景为透明，需要同时在header-cell-style、
header-row-style、row-style三个属性都要放入同样的样式对象，然后css里.el-table类也必须设置同样的样式才能成功更改到这个背景
色。不知道是我方向错了没发现更好的办法，还是table组件本身是这样的，感觉好麻烦啊哈哈哈。
```

##### 1.12
```
    由于开始项目前没有好好规划整个项目，结果基本都是写几段代码就需要调整项目结构，这是个问题，以后得先想好整个结构再开
始，不然浪费的时间太多了。vuex的概念跟之前看的dva很接近，因此上手难度不是太大。

    有个问题是组织Store的结构和一些细节上自己绕了圈子，本身因为传递vuex中的数据到组件中要用mapXXXX系列函数，action和muta-
tion，也可以用$store.commit/dispatch去完成。由于用mapXXX函数输入的是字符串，因此我想是不是全部改成常量去存储会好一点。意思
是将state、getters、action和mutation的key全部用常量代替，方便在特定文件调用，而且更改时也方便，只需要更改一处就可以应用到
整个app，但后来我后悔了，全部都用常量代替，一开始数据不多时还好，后面多起来就可读性和操作都不太好，还增加了代码量。

    其实这是我想太多了，首先因为用了react的思维去想事情，想着store的数据直接传递会不会让store的结构和组件形成强耦合，但其
实这个并不会。毕竟vuex传递到组件的state有多种方式，不是react-redux的mapStateToProp那样，例如想传递状态id时要直接传入state.id
，这样的结构形成强耦合，要解耦还需要另外封装一个如getIdFromState的接口，不把结构暴露，让组件不依赖state树结构。但其实vuex
已经考虑到，因此直接输入字符串就可以调用相应的属性（命名空间module除外），因此我又把自己弄好的常量又删掉，把所有用到这些
常量的文件都改回直接调用字符串。
```

##### 1.13
```
    写好几个组件之后回看一下，博文列表和详情页读取数据的逻辑是一样的，可以复用，于是我写了一个高阶组件，复用的主要是生命
周期函数和导航守卫函数，将子组件插入到高阶组件的slot中达成复用。但有个问题是，即使我写了beforeRouteUpdate函数，但当导航到
不同的博文列表页时没有调用，本身这个函数放在PostList组件调用时时没有问题，但放到高阶组件就不行。而根据文档的提示，这个方
法只有路由变更但组件复用时才会调用，路由方面确实是变更了，高阶组件也应该是复用的，而beforeRouteEnter和beforeRouteLeave两
个导航守卫方法都是可以调用的，因此搞不懂，难道高阶组件的没有真正的被复用？于是用了watch方法，监听$route的路径去触发。

    其实这里我也犯了一个惯性react思维的错误，vue提供的slot其实更多的是想复用ui的逻辑，如果是生命周期或者其他的一些方法和
数据，其实可以用到mixins去完成。于是我把高阶组件的数据调整了一下，做成了mixins，直接混入到子组件中，这个方法能让之前说的
beforeRouteUpdate函数被调用，因此我估计没有之前触发钩子是出在高阶组件身上，可能是组件没有真正的被复用。

    之后在添加过渡特效时遇到了情况，用transition包裹的router-view，只有在不同组件间切换才有效果，复用的组件却没有动画，
很明显这是组件复用没有重新加载导致的问题。在官方文档中过渡特效那一部分，关于需要给复用组件添加特效的话是需要给组件添加上
key值去让它判断这是一个不同的组件，然后展示特效。于是我在路由表中需要用到的所有组件都添加了key值，不出所料没有效果。理论
上操作应该是对的，一开始我以为因为我给的key值是字符串所以不起效，于是将route.path作为key值，这个肯定是唯一的了，但依然不
行。然后在vue-router文档中关于路由过渡那一部分，有介绍到可以用watch $route的方法或者导航守卫钩子去完成，但我感觉太麻烦了，
绑定key应该就能做到的。经过一番尝试后，终于知道在router-view上绑定key值，就能实现过场特效了。之后特意翻查了下router-view
这个组件，官方的介绍说其实这个就是一个动态组件，因此像动态组件绑定特效一样就行了，因为component本身已经用is动态绑定了一个
表示当前组件的值，因此只需要简单包裹就能实现特效，而router-view因为没有添加绑定，因此只要在上面给定一个表示组件的值就可以，
这种情况下最好的办法就是添加route的值了。
```

##### 1.14
```
    调整了一下面包屑导航条的项目，将最后一项动态调整为文章标题，然后再测试时，留意到每次切换组件都会进行两次的数据请求。
仔细看了下mixins的部分后找到原因。因为昨天在处理过渡特效时，在router-view添加了key值，这样导致每个组件都是重新加载的，而
我mixin的部分是包含一个created钩子和一个beforeRouteUpdate的导航守卫，因此每次切换页面都会进行两次请求，在删掉导航守卫后就
解决了。
    
    之后完成了分页功能。这个功能是第一次做，在上一个demo中的分页功能，因为antd的menu组件本身自带pagination属性，简单的添
就能使用。本身以为element也是这样，毕竟antd和element的文档也没有详细介绍这个组件。于是我找了form和table组件看看有没有相关
设定，发现是没有的。后来网上查了下，才知道要自己写方法去过滤的，好吧。。。其实原理很简单，就是输入pageSize和current-page
这两个参数，然后在获取到数据列表的长度后赋值到total属性，根据这三个参数去计算每页显示的条目，将过滤后的数组绑定给表格或
列表就可以了。之后将这部分逻辑做成一个mixin文件，可以服用到博文列表和评论列表组件中。
```

##### 1.15
```
    在处理列表组件的过渡特效时，发现会出现文档说的生硬过渡的情况。文档中是推荐用v-move完成，但我本身是用element组件自带
特效，v-move这个方法好像没有用。于是我添加了leave-active-class，设置离开组件时样式为{opacity: 0, position: absolute}，
算是没有问题了，但这样做的话，特效的过渡有点丑,还是会有点抖动。后来在leave-active-class里设置了变透明的过渡时间为0s，即
添加transition: opacity 0s，这样就没有了退场时的抖动，看上去自然一点。

    之后添加了富文本功能。一开始是选择mavon-editor的，但无奈那个背景色怎样都改不了，于是放弃了改用Vue2Editor，虽然功能比
前者少了点，但基本能满足要求了。由于想复用这个编辑器组件，因此不打算将状态放到state树上，把状态保存在组件里面，这样更方便。
然后就写了一个发布文章、评论的action。之前使用json-server的时候没有仔细看文档，很多filter方法没有用上。这次了解到了几个很
有用的方法，如sort、page、slice方法，可以简化很多操作。上一个demo在发布时，因为不知道这几种查询方式，在获取现有id去生成新
id方面做得比较复杂，要在数据库做一个id池然后在saga里又有进行几次请求和更改。掌握这个方法后，id方面我现在是直接查询所需数据
数组，将其倒序排列后并将第一个返回，返回的对象中的id就是目前最新的id了，跟上一个demo对比，请求次数减少了两次，之后有时间
会对旧demo进行优化。
```

##### 1.16
```
    由于博客展示的部分基本完成，现在想把管理的部分区分开来，把发表博文和管理评论之类的功能整合到去后台，后台地址不展示在
博客的展示页面上。但因为很多逻辑例如发表文章和获取文章，都是跟前台部分很接近的，唯一不同的就是ui页面，于是在想能不能使用
mixins混入生命周期的同时，把这些混入的数据根据不同条件，通过slot传递给不同ui组件。
    
    slot的slot-scope之前不是很了解，以为只是在组件执行v-for时想自定义子组件的样式才使用，但其实除了这个功能外，还能像我
所想那样，调用组件时获取到组件中的，然后在插入子组件时，把先前获取的数据在按需绑定给子组件。虽然现在说着很简单，但我因为
不熟悉，文档的例子也不多，自己尝试了好久，看了几篇文章，才彻底搞清楚这个用法。之后就把原先的获取数据的mixin合并到这个组
件中。
    
    现在调用的思路是，调用这个高阶组件时给一个target属性，去确定获取的内容，通过prop传递给高阶组件，然后高阶组件根据这个
prop去计算应该获取什么数据，并返回。过程中发现，我在data、methods和computed里使用的这个prop是undefined的，记得文档之前说
过类似的情况，于是翻查了一下，知道了因为判断prop是在组件实例创建之前进行验证的，因此判断prop时是获取不到data的属性，但问
题是初始化prop比初始化data要早，为什么我获取不到呢？于是我在生命周期里查看，发现beforeCreate时，prop是undefined的，只有在
组件created后，才能获取到prop的值，于是我试过在computed中使用this.$nexttick方法去看看能不能在下一个循环周期去获取prop，但
发现还是不行，这里实在想不明白，无奈唯有把部分要判断的逻辑放到created后再dispatch一个action去判断。
```

##### 1.17
```
    写后台页面时，部分前台的样式是可以复用的，于是抽象了一下。另外之前element的变量表，由于覆盖的变量都是针对前台的，而
后台的样色有差别，如果使用element的组件时，更改样式比较麻烦。因此在想能不能分开两份变量表做覆盖，加载前台组件时就按前台
设定的变量表去覆盖，切换到后台就按后台的样式去覆盖。刚开始没什么问题的，但发现当我从前台切换到后台时，由于是单页应用，因
此页面没有重新刷新，而是简单的复用了部分组件，如面包屑导航和边栏的样式。刚开始我以为是router-view的原因，尝试像之前设置特
效时那样给router-view组件添加key值，没有效果。然后又尝试给复用的面包屑组件添加key，去表明这两个是不同的组件，但没有效果。
想了很久，查了很多资料，最后得出的结论是，估计是不关组件是否复用的问题，而是因为前后台的两份变量表，虽然样式不同，但变量
是一样的，因此我加载到前台时，前台在的实例在创建时覆盖了变量，但后退到后台时，由于浏览器没有刷新，变量名虽然是那个，但里
面的样式已经被更改了，因此出现这种情况。

    了解了情况后，觉得尝试能不能让前台或者后台组件第一次创建时先刷新页面，但这样做对的效果感觉不大好，会有一种好慢的感觉。
挣扎过后，决定放弃复用scss变量这个想法，改为维护一份前后台的颜色变量及函数文件，所有颜色都经过这里进行管理，然后样式分成
前后台，部分复用的组件加上class或id命名空间，当后台样式跟前台重复时，在用控制台查看element的组件类名，进行覆盖。
```

##### 1.18
```
    这几天都不是很认真去做demo，都是做一会又去弄其他事，所以进度有点慢。
    
    后台主要是通过表格做展示，但问题是因为前台覆盖了变量，现在后台的表格样式也是跟前台的一样的，如果改的话，难道要像之前
一样，在每个组件里做更改吗，有没有更高效的方法，例如从css中直接控制表格的样式，毕竟即使组件能通过属性设定，但根本上来说也
是通过css去更改样式的，因此一定有对应的类名。

    之后花了很多时间在确定element的table组件的类名，仔细逐个地查看，并在控制台里尝试修改看看效果。结果终于找到了个直接控
制table组件样式的类了，其中表头可以通过thead下的tr和th去更改，可以不用类名的，行的样式是通过.el-table__row类去控制，如果想
控制单元格，还需要在这个类下的td元素和.cell类进行更改，另外还有表格头和主体的下方边框线，可以通过刚刚说的th和td，在里面把
border去掉。

    虽然听着很简单，但也是经过了很长时间反复去修改才得到的，这个坑算是踩过去了。在理清这几个类的关系后，我就把之前在前台
组件中用属性形式插入的样式对象去掉，改为统一通过css去控制。
    
    之后把前台categories组件的异步逻辑合并到DataDisplayHOC里去，本来是想减少点重复代码。但后来偶然间发现了，这个做法会在
每次切换跳转路由获取数据时，都会重新创建这个高阶组件的实例，对于边栏来说，实在没必要，毕竟获取的数据量和付出的额外运行量
是反比的，决定回滚到之前的操作，后台的页面和基本ui逻辑已经完成，之后在加入编辑器，还有部分操作交互，demo基本就完成了。
```

##### 1.19
```
    之前在Editor组件时，由于页面中代码较多，于是想将UI逻辑和数据逻辑分成两个文件，方便管理。但本身因为是用v-model去做数据
绑定，因此如果UI组件变成子组件，需要更改绑定的方式。一开始是打算直接value='prop'然后@input='handler'这样的方式，但想了想，
这么多表格选项，每个项都要写handle岂不是很麻烦。想起之前看文档时介绍组件时提到有个sync修饰符，当时不是很理解，于是跳过了。
现在回去再看一遍，感觉有了实际项目经验后看这个变得容易理解。其实就是一个语法糖，父组件可以写少一个函数，子组件也只需要声明
一个事件，把值传给父组件就行。
```

##### 1.20
```
    之前在弄后台表格的时候，加入筛选功能后在打开筛选列表时会报错，提示el-scrollbar没有正确注册。我就懵了，难道这功能还调
用另一个element组件？于是我就尝试注册这个Scrollbar，没有保存时发现WebStorm提示没有这个组件，于是我查看文档看看这个组件的
注册名是什么，发现居然没有。百度了下原来这是一个隐藏组件，官方没有打算加入到文档中，估计是太简单的组件所以不愿意写。注册
方法其实就是我之前那样，只不过我没有保存去尝试，太相信WebStorm的提示了。

    然后今天把部分组件的跳转方式，从根据path换成params，因为部分组件例如Editor和Aside，获取和发送数据的方式都是根据path
去做判断，感觉这样不太好，跟路径的顺序耦合在一起了，于是改成了通过传参的形式去做跳转，这样就不依赖路径了。然后将前后台的
边栏UI逻辑提取成一个公用的UI组件，这样前后台传入不同的参数和样式可以得到不到的边栏。
```
##### 1.21
```
    今天主要完成了后台的一些修改和新增功能，暂时只完成了文章和分类的增改。思路大概就是点击操作栏上的修改按钮，文章的话会
获取该列对应文章详情，保存到组件自身的data中，然后传入Editor组件；分类的更改也类似，只不过是直接在组件渲染输入框，并将数
据传入，在上面进行更改。

    其中在处理Editor组件时比较复杂，因为很多按钮的渲染是根据当前的状态去完成的，所以UI组件里有很多条件判断的代码，感觉不
太优雅。另外处理传值方面也遇到点瓶颈，一开始由于要在PostList的UI子组件里，点击编辑按钮后，通过事件将表格的每一行的内容传
到兄弟组件Editor里面，所以在PostList组件的最外层添加了data，把数据通过事件传入data里保存，然后再根据判断语句，将动态组件
的分页转到Eidtor并把作为prop的数据传入Editor组件的输入框里。一开始我思路是点击编辑按键后，执行事件，将数据传入PostList的
data里。因为Editor方面的表单数放在data里获取不到传入的props，因此我放在computed，让props更新的时候就计算出现有的内容，
测试读取的话是没有问题，但当我尝试输入内容时，虽然表单里内容时改变了，但发送到服务器后查到的却是没有改变。经过查看，问题
出在我把表单数据放在computed里而没有设置set值。由于表单的结构是通过.sync修饰符去双向绑定，如果改为computed工程量会好大，
而且如何对一个对象不同的属性通过set去设置不同的值也是个问题，这样改变感觉太麻烦了。于是另辟途径，把数据放回data里，然后尝
试用updated钩子方法去做，但问题是输入内容时组件也是会执行updated()的，因此没用。最后用watch监听props，一有变动时就将数据
传入。

    而BackCategory组件的增删，对我来说难点在于如何在表格中完成，虽然思路是通过v-if判断渲染单元格还是输入框，编辑是很简单，
但新增的话比较麻烦。看element文档好像没有看到有关于动态新增表格的方法，于是自己实现。通过它的table-slot插入一个按钮，点击
后就往表格的data属性绑定的数组添加一项，然后把当前状态转变为编辑状态，删除的话就点击取消按钮，查找数组中最后一项，如没有
id值就用pop()方法删除掉。因为我传入到表格data属性的数组是从getters里计算出来的，过滤了About组件对应的条目，因为记得之前说
过更改state的数据必须通过mutation修改，所以一开始我是在BackCategory组件里在创建一个计算值，保存这个getters的列表数据，但
感觉好像有点多此一举。记起vuex有严格模式，于是开启后试试直接更改getters会不会报错。经测试后，我在这个getters返回的数组中
进行push和pop都没有报错，证明其实getters里的值并不像state那样严格，可以自行改动的。

    然后因为PostList组件有两个方法，需要分别传递到UI子组件和Ediotr的UI组件里，一开始是$emit事件到容器组件，然后容器组件在
$emit事件到父组件。显然，这种做法很low，但我又不想把这些方法放入vuex，毕竟这些方法不需要共享给其他组件，也不涉及状态，而
且最重要是使用麻烦。Vue提供了provide和inject这个依赖注入的方法，有点像mobx，但官方文档不是很建议用的，毕竟这种形式传递的
数据并不是响应式的。但我感觉这种情况应该没关系，这两个方法都不需要响应式的，因此决定使用这个途径去注入方法。而且很好的是
这个可以根据条件确定是否inject，inject的时候可以是一个对象，这样就可以用二元运算或三元运算去做判断是否传入数据。

    demo现在只剩下后台评论页的增改逻辑，完成后尝试去学习下node.js方面知识，增加真正的后台功能，代替现在的json-server。
```
##### 1.22
```
    今天检查昨天写的组件时，发现BackPostList组件出现bug，在进入编辑模式后放弃修改回到列表页，再进入编辑器组件会发现数据没
有清空。昨天写的时候测试好是没有问题的，不知道是不是因为改动了其他组件而出现问题。仔细翻看了昨天改动的部分，也找不到原因。
但估计不是其他组件的问题。于是我就在BackPostList组件和Editor里相应的地方插入console.log去观察整个过程的执行。终于被我发现
了问题出在什么地方。第一个，因为我BackPostList组件的amenData，更改时是Object.assign(amendData,{...})这样混入数据，因此
Editor组件观察的时候其实是没有变动的，本身我以为放在组件data里的所有数据都是响应式的，但估计可能我没有预先设置好相关对象
的key，因为新建的属性并不是响应式的，除非我用$set方法添加，或创建一个新数组。第二点就出在Editor组件的watch方法上，由于某
个判定语句导致amendData改动后没有及时更新数据，因此就导致上述的bug。之后就将amendData的数据变动改为对象扩展符完成，这样就
返回一个新对象了，然后删除掉出错的判断语句，问题解决。

    新增BackPost后台详情页组件时，发现跳转的时候会丢失样式，或者样式错乱。由于很多组件的css部分我都没有加上scope，而且后
台方面很多css我都是集中写在一个文件中，因此虽然组件也是在后台的router-view里做跳转，但离开后导致样式丢失，加载了element的
默认变量颜色。经过一番调试，最后调整了下样式的加载位置，放到前后台组件对应的index文件中加载，并且给两个组件都加上类名，
之前问题就消失了。

    另外对BackPostList组件增加了些交互功能，在发布页离开时想做提示，询问是否离开，用默认的window.confirm去完成。
```
##### 1.23
```
    完成详情页后，发现评论部分的UI数据很接近，只是样式不同，接受的props都是一样的，于是提取成一个公用的UI组件，调取时加载
不同的css。同时也提取了边栏的UI数据，都做成公用的UI组件。

    在测试昨天写的BackPostList组件时，发现路由跳转时没有弹出提示，原因是因为我没有写导航守卫函数，这个很容易就解决了。之
后尝试将默认的confirm用element的弹框组件代替。这里就出现问题了。因为element的MessageBox组件，confirm是用异步函数完成的，
因此需要调整逻辑。活动分页改变时要的改动要换成async/await的形式，同时守卫导航也要。而且因为是异步进行，因此有些本应按顺序
完成的步骤没有完成或者提前完成。例如我在发表页，按边栏按钮跳转到其他页面，跳转前应该是询问是否离开，当我取消掉的时候，页
面却依然跳转了。于是我在控制取消的handleCancel函数里，加上一个返回值，返回的是confirm组件询问的结果。然后根据这个结果，
在导航守卫里做判断，如果返回确定就next()跳转，如果否就不跳转。但实际情况是即使我在beforeRouteLeave里的判定失败的情况下返
回false，页面还是会如常跳转。因为我设置了这个判断是在特定条件下才触发，为了不影响正常的跳转，因此最后如果不符合条件，最后
会自动next()到下一个路由。按道理如果条件符合，有运行到if里面的代码，return的时候是应该就会终止，难道是因为异步的原因吗？
但应该不会，因为我获取值的时候都用了await，等到异步完成才返回值，因此不应该会这样。于是我决定不return false，而是返回next()，
不同的是跳转的目标是当前的路由。测试后发现还是不行，我就纳闷了，怎么这样，然后苦思冥想，突然想到$nextTick，于是尝试一下，
在判断失败时this.$nextTick(() => { return next({ ...from }) })。于是，问题就解决了，经过分析，估计是因为befroeRouteLeave
这个方法里，判断失败时候的next里面的对象，当前事件循环是执行不到，只执行了next依然跳转到下一个路由，如果要异步执行，就放
到下一个事件循环里，因此就能陈宫伪取消导航了。

    之后用element的Notification组件和MessageBox组件，做了个Mixins，用于在请求失败时的回调，起提醒作用。
    
    然后在后台评论列表页中，按查看的话是会跳转到所在的文章详情页。现在给自己加个需求，在跳转完成后屏幕滚动到相应的评论位
置。这个情况下第一时间是想起a元素的锚点，但问题时现在通过vue-router跳转，怎样去加锚点呢？文档中提到这个滚动的有一个方法
scrollBehavier，但看了很久，都不是很明白他到底能不能完成我这个需求，然后网上查了一下，基本是说这个scrollBehavior方法的，
没什么养分。因此另辟途径，自己尝试实现。

    首先普通情况下，实现锚点需要在目标位置放置一个id属性去做识别，因此我在渲染时加入id，用该评论所在的文章id和评论本身的
id合并作为这个元素的id。然后并在列表页按跳转时的router-link中附带着该条目的详细信息，为的是跳转后可以得到对应的数据，实现
滑动。到了详情页里面的时候，一开始思路是在mounted钩子函数下用document.querySelector去根据路由附带的信息去查找元素，然后
使用scrollIntoView实现滑动。但问题时在mounted里我不能获取到元素，总是提示undefined。正常mounted了之后应该是能查询到元素了。
难道是因为vnode的缘故？于是改用ref，这次能获取了，但问题是返回空数组。想了很久终于想起因为mounted时组件的list状态是空的，
需要我发起的请求成功并更新store里list状态才会返回数据，因此我把mounted换成updated，然后现在就能实现到跳转到锚点了。
```
##### 1.24
```
    现在基本进入尾声了，调整了部分代码，把后台部分组件一些类似或公用的状态和方法放入vuex中，并把store分割成三个部分，分别
对应前台，后台和公用部分，这样的话，前后台的功能上互相独立运行的，可以放在不同的域里，互相没有影响，能同时操作同一个数据库。
不过这个分离的过程花费时间很长，毕竟初期设计时没有考虑到之后会做分割，因此这个要在同一个store里分割不同的部分弄了很久。
    
    然后把后台的PostList和Comments组件里的关于编辑博文和帖子的逻辑提取出来，做成mixins，精简掉类似的代码。然后添加404页面，
过程中发现了之前封装的DatadDisplayHOC和asyncFetch组件中，获取博文的数据部分逻辑不严谨，仅仅通过路径提供的id去查找，而没有
判断路径是否合法，因此对两个部分做了调整，加入了一个过滤条件给post的请求，除了按id请求post外，还需要判断post的分类是否跟
路径对象里提供的分类一致，如果不一致就返回错误。然后完成这部分后，想到了本身评论部分的数据其实可以跟博文部分一起加载，高
阶组件不需要分别包裹两个组件，而应该是同时包裹两个组件，这样不仅发出请求的逻辑没有改变，而且能减少高阶组件的一次运行。
于是精简掉代码，并且在高阶组件里加一个判断，如果当前正在请求博文并请求成功后在请求评论列表。之后就删减掉部分容器组件。
然后将之前写好的请求失败的mixins方法里，加入跳转到404页面组件的功能。现在基本整个demo都完成了90%了，剩下后台登录的逻辑。
明天写好静态页面后，就尝试学习node.js，搭建一个真正的服务器，并学习json token等相关知识。
```