## 踩坑记录
> 这是我学习完vue系列后做的第一个demo，看了大概4天的文档和各种文章，就开始做的，虽然很多概念跟react相似，但由于模板语法不
同，罪人网友都说vue比react容易，都说JSX语法难懂，但不知道怎的我觉得JSX的语法更加清晰，感觉vue反而复杂一点。有的地方还不是
很熟练，因此虽然逻辑跟上一个demo大同小异，但做的时间还是有点长，下面记录下过程中遇到的问题和解决办法，总结一下。

##### 1.11
```
    上一个demo使用less的时候都没有真正地使用mixin和全局变量，都是像平常写css一样，最多也就用到嵌套而已。这次使用element，
顺便可以学习scss，vue-cli很方便，创建项目时就直接可以部署好scss的环境。然后当我想使用全局变量时，按照文档的介绍，需要在
webpack去添加，但问题是我没有找到文档中所说的webpack的配置文档。后来才知道vue-cli3更改为编辑vue.config.js去设定，在这里
耽误的时间较长。
    
    之后就轮到使用element的问题了，由于想自定义样式，尝试按文档自定义主题部分的命令行方法去生成主题，但总是提示需要先安
装element-theme-chalk，但我已经安装了，依然不行，无奈之下自行创建scss文件，引入element的变量表，然后做变量覆盖。

    之后第一次使用scss的mixin和变量，感觉十分便捷，虽然很多高级用法还是没有熟练，但确实效率高了很多，后悔没有早点用。之后
时间都基本花在调整样式上。

    过程有个问题，就是element的table组件，它的背景色，我直接在.el-table和.el-table-column设置，没有反应，然后打开控制台，
直接设置.el-table__row的样式，还是有问题的。具体情况是，我想将背景设置为半透明，但无论怎么设置，表格总会有一个白色底色，
我尝试将我在控制台看到的所有table下的class都设置样式，还是改变不到。然后想到是不是默认变量导致，于是把table相关的变量全部
覆盖了一遍，无效。于是网上查了一下，好像没有人提起。翻查文档，看到table有几个属性，可以更改样式，但试了下添加样式对象到
row-style，是不行的没效果。在上面耗了好久，甚至一度想放弃表格，想用列表代替。后来把心一横，试一下将有关更高组件样式的属
性都赋值上样式，同时css也设置好样式，结果居然起效了。。。后来经过调试，发现要更改背景为透明，需要同时在header-cell-style、
header-row-style、row-style三个属性都要放入同样的样式对象，然后css里.el-table类也必须设置同样的样式才能成功更改到这个背景
色。不知道是我方向错了没发现更好的办法，还是table组件本身是这样的，感觉好麻烦啊哈哈哈。
```

##### 1.12
```
    由于开始项目前没有好好规划整个项目，结果基本都是写几段代码就需要调整项目结构，这是个问题，以后得先想好整个结构再开
始，不然浪费的时间太多了。vuex的概念跟之前看的dva很接近，因此上手难度不是太大。

    有个问题是组织Store的结构和一些细节上自己绕了圈子，本身因为传递vuex中的数据到组件中要用mapXXXX系列函数，action和muta-
tion，也可以用$store.commit/dispatch去完成。由于用mapXXX函数输入的是字符串，因此我想是不是全部改成常量去存储会好一点。意思
是将state、getters、action和mutation的key全部用常量代替，方便在特定文件调用，而且更改时也方便，只需要更改一处就可以应用到
整个app，但后来我后悔了，全部都用常量代替，一开始数据不多时还好，后面多起来就可读性和操作都不太好，还增加了代码量。

    其实这是我想太多了，首先因为用了react的思维去想事情，想着store的数据直接传递会不会让store的结构和组件形成强耦合，但其
实这个并不会。毕竟vuex传递到组件的state有多种方式，不是react-redux的mapStateToProp那样，例如想传递状态id时要直接传入state.id
，这样的结构形成强耦合，要解耦还需要另外封装一个如getIdFromState的接口，不把结构暴露，让组件不依赖state树结构。但其实vuex
已经考虑到，因此直接输入字符串就可以调用相应的属性（命名空间module除外），因此我又把自己弄好的常量又删掉，把所有用到这些
常量的文件都改回直接调用字符串。
```

##### 1.13
```
    写好几个组件之后回看一下，帖子列表和详情页读取数据的逻辑是一样的，可以复用，于是我写了一个高阶组件，复用的主要是生命
周期函数和导航守卫函数，将子组件插入到高阶组件的slot中达成复用。但有个问题是，即使我写了beforeRouteUpdate函数，但当导航到
不同的帖子列表页时没有调用，本身这个函数放在PostList组件调用时时没有问题，但放到高阶组件就不行。而根据文档的提示，这个方
法只有路由变更但组件复用时才会调用，路由方面确实是变更了，高阶组件也应该是复用的，而beforeRouteEnter和beforeRouteLeave两
个导航守卫方法都是可以调用的，因此搞不懂，难道高阶组件的没有真正的被复用？于是用了watch方法，监听$route的路径去触发。

    其实这里我也犯了一个惯性react思维的错误，vue提供的slot其实更多的是想复用ui的逻辑，如果是生命周期或者其他的一些方法和
数据，其实可以用到mixins去完成。于是我把高阶组件的数据调整了一下，做成了mixins，直接混入到子组件中，这个方法能让之前说的
beforeRouteUpdate函数被调用，因此我估计没有之前触发钩子是出在高阶组件身上，可能是组件没有真正的被复用。

    之后在添加过渡特效时遇到了情况，用transition包裹的router-view，只有在不同组件间切换才有效果，复用的组件却没有动画，
很明显这是组件复用没有重新加载导致的问题。在官方文档中过渡特效那一部分，关于需要给复用组件添加特效的话是需要给组件添加上
key值去让它判断这是一个不同的组件，然后展示特效。于是我在路由表中需要用到的所有组件都添加了key值，不出所料没有效果。理论
上操作应该是对的，一开始我以为因为我给的key值是字符串所以不起效，于是将route.path作为key值，这个肯定是唯一的了，但依然不
行。然后在vue-router文档中关于路由过渡那一部分，有介绍到可以用watch $route的方法或者导航守卫钩子去完成，但我感觉太麻烦了，
绑定key应该就能做到的。经过一番尝试后，终于知道在router-view上绑定key值，就能实现过场特效了。之后特意翻查了下router-view
这个组件，官方的介绍说其实这个就是一个动态组件，因此像动态组件绑定特效一样就行了，因为component本身已经用is动态绑定了一个
表示当前组件的值，因此只需要简单包裹就能实现特效，而router-view因为没有添加绑定，因此只要在上面给定一个表示组件的值就可以，
这种情况下最好的办法就是添加route的值了。
```