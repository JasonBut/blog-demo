## 踩坑记录
> 这是我学习完vue系列后做的第一个demo，看了大概4天的文档和各种文章，就开始做的，虽然很多概念跟react相似，但由于模板语法不
同，罪人网友都说vue比react容易，都说JSX语法难懂，但不知道怎的我觉得JSX的语法更加清晰，感觉vue反而复杂一点。有的地方还不是
很熟练，因此虽然逻辑跟上一个demo大同小异，但做的时间还是有点长，下面记录下过程中遇到的问题和解决办法，总结一下。

##### 1.11
```
    上一个demo使用less的时候都没有真正地使用mixin和全局变量，都是像平常写css一样，最多也就用到嵌套而已。这次使用element，
顺便可以学习scss，vue-cli很方便，创建项目时就直接可以部署好scss的环境。然后当我想使用全局变量时，按照文档的介绍，需要在
webpack去添加，但问题是我没有找到文档中所说的webpack的配置文档。后来才知道vue-cli3更改为编辑vue.config.js去设定，在这里
耽误的时间较长。
    
    之后就轮到使用element的问题了，由于想自定义样式，尝试按文档自定义主题部分的命令行方法去生成主题，但总是提示需要先安
装element-theme-chalk，但我已经安装了，依然不行，无奈之下自行创建scss文件，引入element的变量表，然后做变量覆盖。然后当我
保存后发现报错说找不到文件，我以为我的vue.config.js配置错误了，在网上查了好久，后来才发现其实修改vue conifg文件后需要重新
运行yarn run serve，否则vue-loader会出现错误。。。

    之后第一次使用scss的mixin和变量，感觉十分便捷，虽然很多高级用法还是没有熟练，但确实效率高了很多，后悔没有早点用。之后
时间都基本花在调整样式上。

    过程有个问题，就是element的table组件，它的背景色，我直接在.el-table和.el-table-column设置，没有反应，然后打开控制台，
直接设置.el-table__row的样式，还是有问题的。具体情况是，我想将背景设置为半透明，但无论怎么设置，表格总会有一个白色底色，
我尝试将我在控制台看到的所有table下的class都设置样式，还是改变不到。然后想到是不是默认变量导致，于是把table相关的变量全部
覆盖了一遍，无效。于是网上查了一下，好像没有人提起。翻查文档，看到table有几个属性，可以更改样式，但试了下添加样式对象到
row-style，是不行的没效果。在上面耗了好久，甚至一度想放弃表格，想用列表代替。后来把心一横，试一下将有关更高组件样式的属
性都赋值上样式，同时css也设置好样式，结果居然起效了。。。后来经过调试，发现要更改背景为透明，需要同时在header-cell-style、
header-row-style、row-style三个属性都要放入同样的样式对象，然后css里.el-table类也必须设置同样的样式才能成功更改到这个背景
色。不知道是我方向错了没发现更好的办法，还是table组件本身是这样的，感觉好麻烦啊哈哈哈。
```

##### 1.12
```
    由于开始项目前没有好好规划整个项目，结果基本都是写几段代码就需要调整项目结构，这是个问题，以后得先想好整个结构再开
始，不然浪费的时间太多了。vuex的概念跟之前看的dva很接近，因此上手难度不是太大。

    有个问题是组织Store的结构和一些细节上自己绕了圈子，本身因为传递vuex中的数据到组件中要用mapXXXX系列函数，action和muta-
tion，也可以用$store.commit/dispatch去完成。由于用mapXXX函数输入的是字符串，因此我想是不是全部改成常量去存储会好一点。意思
是将state、getters、action和mutation的key全部用常量代替，方便在特定文件调用，而且更改时也方便，只需要更改一处就可以应用到
整个app，但后来我后悔了，全部都用常量代替，一开始数据不多时还好，后面多起来就可读性和操作都不太好，还增加了代码量。

    其实这是我想太多了，首先因为用了react的思维去想事情，想着store的数据直接传递会不会让store的结构和组件形成强耦合，但其
实这个并不会。毕竟vuex传递到组件的state有多种方式，不是react-redux的mapStateToProp那样，例如想传递状态id时要直接传入state.id
，这样的结构形成强耦合，要解耦还需要另外封装一个如getIdFromState的接口，不把结构暴露，让组件不依赖state树结构。但其实vuex
已经考虑到，因此直接输入字符串就可以调用相应的属性（命名空间module除外），因此我又把自己弄好的常量又删掉，把所有用到这些
常量的文件都改回直接调用字符串。
```

##### 1.13
```
    写好几个组件之后回看一下，博文列表和详情页读取数据的逻辑是一样的，可以复用，于是我写了一个高阶组件，复用的主要是生命
周期函数和导航守卫函数，将子组件插入到高阶组件的slot中达成复用。但有个问题是，即使我写了beforeRouteUpdate函数，但当导航到
不同的博文列表页时没有调用，本身这个函数放在PostList组件调用时时没有问题，但放到高阶组件就不行。而根据文档的提示，这个方
法只有路由变更但组件复用时才会调用，路由方面确实是变更了，高阶组件也应该是复用的，而beforeRouteEnter和beforeRouteLeave两
个导航守卫方法都是可以调用的，因此搞不懂，难道高阶组件的没有真正的被复用？于是用了watch方法，监听$route的路径去触发。

    其实这里我也犯了一个惯性react思维的错误，vue提供的slot其实更多的是想复用ui的逻辑，如果是生命周期或者其他的一些方法和
数据，其实可以用到mixins去完成。于是我把高阶组件的数据调整了一下，做成了mixins，直接混入到子组件中，这个方法能让之前说的
beforeRouteUpdate函数被调用，因此我估计没有之前触发钩子是出在高阶组件身上，可能是组件没有真正的被复用。

    之后在添加过渡特效时遇到了情况，用transition包裹的router-view，只有在不同组件间切换才有效果，复用的组件却没有动画，
很明显这是组件复用没有重新加载导致的问题。在官方文档中过渡特效那一部分，关于需要给复用组件添加特效的话是需要给组件添加上
key值去让它判断这是一个不同的组件，然后展示特效。于是我在路由表中需要用到的所有组件都添加了key值，不出所料没有效果。理论
上操作应该是对的，一开始我以为因为我给的key值是字符串所以不起效，于是将route.path作为key值，这个肯定是唯一的了，但依然不
行。然后在vue-router文档中关于路由过渡那一部分，有介绍到可以用watch $route的方法或者导航守卫钩子去完成，但我感觉太麻烦了，
绑定key应该就能做到的。经过一番尝试后，终于知道在router-view上绑定key值，就能实现过场特效了。之后特意翻查了下router-view
这个组件，官方的介绍说其实这个就是一个动态组件，因此像动态组件绑定特效一样就行了，因为component本身已经用is动态绑定了一个
表示当前组件的值，因此只需要简单包裹就能实现特效，而router-view因为没有添加绑定，因此只要在上面给定一个表示组件的值就可以，
这种情况下最好的办法就是添加route的值了。
```

##### 1.14
```
    调整了一下面包屑导航条的项目，将最后一项动态调整为文章标题，然后再测试时，留意到每次切换组件都会进行两次的数据请求。
仔细看了下mixins的部分后找到原因。因为昨天在处理过渡特效时，在router-view添加了key值，这样导致每个组件都是重新加载的，而
我mixin的部分是包含一个created钩子和一个beforeRouteUpdate的导航守卫，因此每次切换页面都会进行两次请求，在删掉导航守卫后就
解决了。
    
    之后完成了分页功能。这个功能是第一次做，在上一个demo中的分页功能，因为antd的menu组件本身自带pagination属性，简单的添
就能使用。本身以为element也是这样，毕竟antd和element的文档也没有详细介绍这个组件。于是我找了form和table组件看看有没有相关
设定，发现是没有的。后来网上查了下，才知道要自己写方法去过滤的，好吧。。。其实原理很简单，就是输入pageSize和current-page
这两个参数，然后在获取到数据列表的长度后赋值到total属性，根据这三个参数去计算每页显示的条目，将过滤后的数组绑定给表格或
列表就可以了。之后将这部分逻辑做成一个mixin文件，可以服用到博文列表和评论列表组件中。
```

##### 1.15
```
    在处理列表组件的过渡特效时，发现会出现文档说的生硬过渡的情况。文档中是推荐用v-move完成，但我本身是用element组件自带
特效，v-move这个方法好像没有用。于是我添加了leave-active-class，设置离开组件时样式为{opacity: 0, position: absolute}，
算是没有问题了，但这样做的话，特效的过渡有点丑,还是会有点抖动。后来在leave-active-class里设置了变透明的过渡时间为0s，即
添加transition: opacity 0s，这样就没有了退场时的抖动，看上去自然一点。

    之后添加了富文本功能。一开始是选择mavon-editor的，但无奈那个背景色怎样都改不了，于是放弃了改用Vue2Editor，虽然功能比
前者少了点，但基本能满足要求了。由于想复用这个编辑器组件，因此不打算将状态放到state树上，把状态保存在组件里面，这样更方便。
然后就写了一个发布文章、评论的action。之前使用json-server的时候没有仔细看文档，很多filter方法没有用上。这次了解到了几个很
有用的方法，如sort、page、slice方法，可以简化很多操作。上一个demo在发布时，因为不知道这几种查询方式，在获取现有id去生成新
id方面做得比较复杂，要在数据库做一个id池然后在saga里又有进行几次请求和更改。掌握这个方法后，id方面我现在是直接查询所需数据
数组，将其倒序排列后并将第一个返回，返回的对象中的id就是目前最新的id了，跟上一个demo对比，请求次数减少了两次，之后有时间
会对旧demo进行优化。
```

##### 1.16
```
    由于博客展示的部分基本完成，现在想把管理的部分区分开来，把发表博文和管理评论之类的功能整合到去后台，后台地址不展示在
博客的展示页面上。但因为很多逻辑例如发表文章和获取文章，都是跟前台部分很接近的，唯一不同的就是ui页面，于是在想能不能使用
mixins混入生命周期的同时，把这些混入的数据根据不同条件，通过slot传递给不同ui组件。
    
    slot的slot-scope之前不是很了解，以为只是在组件执行v-for时想自定义子组件的样式才使用，但其实除了这个功能外，还能像我
所想那样，调用组件时获取到组件中的，然后在插入子组件时，把先前获取的数据在按需绑定给子组件。虽然现在说着很简单，但我因为
不熟悉，文档的例子也不多，自己尝试了好久，看了几篇文章，才彻底搞清楚这个用法。之后就把原先的获取数据的mixin合并到这个组
件中。
    
    现在调用的思路是，调用这个高阶组件时给一个target属性，去确定获取的内容，通过prop传递给高阶组件，然后高阶组件根据这个
prop去计算应该获取什么数据，并返回。过程中发现，我在data、methods和computed里使用的这个prop是undefined的，记得文档之前说
过类似的情况，于是翻查了一下，知道了因为判断prop是在组件实例创建之前进行验证的，因此判断prop时是获取不到data的属性，但问
题是初始化prop比初始化data要早，为什么我获取不到呢？于是我在生命周期里查看，发现beforeCreate时，prop是undefined的，只有在
组件created后，才能获取到prop的值，于是我试过在computed中使用this.$nexttick方法去看看能不能在下一个循环周期去获取prop，但
发现还是不行，这里实在想不明白，无奈唯有把部分要判断的逻辑放到created后再dispatch一个action去判断。
```

##### 1.17
```
    写后台页面时，部分前台的样式是可以复用的，于是抽象了一下。另外之前element的变量表，由于覆盖的变量都是针对前台的，而
后台的样色有差别，如果使用element的组件时，更改样式比较麻烦。因此在想能不能分开两份变量表做覆盖，加载前台组件时就按前台
设定的变量表去覆盖，切换到后台就按后台的样式去覆盖。刚开始没什么问题的，但发现当我从前台切换到后台时，由于是单页应用，因
此页面没有重新刷新，而是简单的复用了部分组件，如面包屑导航和边栏的样式。刚开始我以为是router-view的原因，尝试像之前设置特
效时那样给router-view组件添加key值，没有效果。然后又尝试给复用的面包屑组件添加key，去表明这两个是不同的组件，但没有效果。
想了很久，查了很多资料，最后得出的结论是，估计是不关组件是否复用的问题，而是因为前后台的两份变量表，虽然样式不同，但变量
是一样的，因此我加载到前台时，前台在的实例在创建时覆盖了变量，但后退到后台时，由于浏览器没有刷新，变量名虽然是那个，但里
面的样式已经被更改了，因此出现这种情况。

    了解了情况后，觉得尝试能不能让前台或者后台组件第一次创建时先刷新页面，但这样做对的效果感觉不大好，会有一种好慢的感觉。
挣扎过后，决定放弃复用scss变量这个想法，改为维护一份前后台的颜色变量及函数文件，所有颜色都经过这里进行管理，然后样式分成
前后台，部分复用的组件加上class或id命名空间，当后台样式跟前台重复时，在用控制台查看element的组件类名，进行覆盖。
```

##### 1.18
```
    这几天都不是很认真去做demo，都是做一会又去弄其他事，所以进度有点慢。
    
    后台主要是通过表格做展示，但问题是因为前台覆盖了变量，现在后台的表格样式也是跟前台的一样的，如果改的话，难道要像之前
一样，在每个组件里做更改吗，有没有更高效的方法，例如从css中直接控制表格的样式，毕竟即使组件能通过属性设定，但根本上来说也
是通过css去更改样式的，因此一定有对应的类名。

    之后花了很多时间在确定element的table组件的类名，仔细逐个地查看，并在控制台里尝试修改看看效果。结果终于找到了个直接控
制table组件样式的类了，其中表头可以通过thead下的tr和th去更改，可以不用类名的，行的样式是通过.el-table__row类去控制，如果想
控制单元格，还需要在这个类下的td元素和.cell类进行更改，另外还有表格头和主体的下方边框线，可以通过刚刚说的th和td，在里面把
border去掉。

    虽然听着很简单，但也是经过了很长时间反复去修改才得到的，这个坑算是踩过去了。在理清这几个类的关系后，我就把之前在前台
组件中用属性形式插入的样式对象去掉，改为统一通过css去控制。
    
    之后把前台categories组件的异步逻辑合并到DataDisplayHOC里去，本来是想减少点重复代码。但后来偶然间发现了，这个做法会在
每次切换跳转路由获取数据时，都会重新创建这个高阶组件的实例，对于边栏来说，实在没必要，毕竟获取的数据量和付出的额外运行量
是反比的，决定回滚到之前的操作，后台的页面和基本ui逻辑已经完成，之后在加入编辑器，还有部分操作交互，demo基本就完成了。
```

##### 1.19
```
    之前在Editor组件时，由于页面中代码较多，于是想将UI逻辑和数据逻辑分成两个文件，方便管理。但本身因为是用v-model去做数据
绑定，因此如果UI组件变成子组件，需要更改绑定的方式。一开始是打算直接value='prop'然后@input='handler'这样的方式，但想了想，
这么多表格选项，每个项都要写handle岂不是很麻烦。想起之前看文档时介绍组件时提到有个sync修饰符，当时不是很理解，于是跳过了。
现在回去再看一遍，感觉有了实际项目经验后看这个变得容易理解。其实就是一个语法糖，父组件可以写少一个函数，子组件也只需要声明
一个事件，把值传给父组件就行。
```

##### 1.20
```
    之前在弄后台表格的时候，加入筛选功能后在打开筛选列表时会报错，提示el-scrollbar没有正确注册。我就懵了，难道这功能还调
用另一个element组件？于是我就尝试注册这个Scrollbar，没有保存时发现WebStorm提示没有这个组件，于是我查看文档看看这个组件的
注册名是什么，发现居然没有。百度了下原来这是一个隐藏组件，官方没有打算加入到文档中，估计是太简单的组件所以不愿意写。注册
方法其实就是我之前那样，只不过我没有保存去尝试，太相信WebStorm的提示了。

    然后今天把部分组件的跳转方式，从根据path换成params，因为部分组件例如Editor和Aside，获取和发送数据的方式都是根据path
去做判断，感觉这样不太好，跟路径的顺序耦合在一起了，于是改成了通过传参的形式去做跳转，这样就不依赖路径了。然后将前后台的
边栏UI逻辑提取成一个公用的UI组件，这样前后台传入不同的参数和样式可以得到不到的边栏。
```
##### 1.21
```
    今天主要完成了后台的一些修改和新增功能，暂时只完成了文章和分类的增改。思路大概就是点击操作栏上的修改按钮，文章的话会
获取该列对应文章详情，保存到组件自身的data中，然后传入Editor组件；分类的更改也类似，只不过是直接在组件渲染输入框，并将数
据传入，在上面进行更改。

    其中在处理Editor组件时比较复杂，因为很多按钮的渲染是根据当前的状态去完成的，所以UI组件里有很多条件判断的代码，感觉不
太优雅。另外处理传值方面也遇到点瓶颈，一开始由于要在PostList的UI子组件里，点击编辑按钮后，通过事件将表格的每一行的内容传
到兄弟组件Editor里面，所以在PostList组件的最外层添加了data，把数据通过事件传入data里保存，然后再根据判断语句，将动态组件
的分页转到Eidtor并把作为prop的数据传入Editor组件的输入框里。一开始我思路是点击编辑按键后，执行事件，将数据传入PostList的
data里。因为Editor方面的表单数据，因为data里获取不到传入的props，因此我放在computed，让props更新的时候就计算出现有的内容，
测试读取的话是没有问题，但当我尝试输入内容时，虽然表单里内容时改变了，但发送到服务器后查到的却是没有改变。经过查看，问题
出在我把表单数据放在computed里而没有设置set值。由于表单的结构是通过.sync修饰符去双向绑定，如果改为computed工程量会好大，
而且如何在同一个对象不同属性的情况下，通过set去设置不同的值也是个问题，这样改变感觉太麻烦了。于是另辟途径，把数据放回data
里，然后尝试用updated钩子方法去做，但问题时输入内容时组件也是会执行updated()的，因此没用。最后用watch监听props，一有变动
时就将数据传入。

    而分类组件的增删，对我来说难点在于如何在表格中完成，虽然思路是通过v-if判断渲染单元格还是输入框，编辑是很简单，但新增
的话比较麻烦。看element文档好像没有看到有关于动态新增表格的方法，于是自己实现了个。通过它的table-slot插入一个按钮，点击后
就往表格的data属性绑定的数组添加一项，然后把当前状态转变为编辑状态，删除的话就点击取消按钮，之后就查找数组中最后一项，然后
pop()方法删除掉。因为我传入到表格data属性的数组是从getters里计算出来的，过滤了About组件对应的项目，因为记得之前说过更改
state的数据必须通过mutation，所以一开始我是在BackCategory组件里在创建一个计算值，保存这个getters的列表数据，但感觉好像有点
多此一举。记起vuex有严格模式，于是开启后试试直接更改getters会不会报错。经测试后，我在这个getters返回的数组中进行push和pop
都没有报错，证明其实getters里的值并不像state那样严格，可以自行改动的。

    然后因为PostList组件有两个方法，需要分别传递到UI子组件和Ediotr的UI组件里，一开始是$emit事件到容器组件，然后容器组件在
$emit事件到父组件。显然，这种做法很low，但我又不想把这些方法放入vuex，毕竟这些方法不需要共享给其他组件，也不涉及状态，而
且最重要是使用麻烦。Vue提供了provide和inject这个依赖注入的方法，有点像mobx，但官方文档不是很建议用的，毕竟这种形式传递的
数据并不是响应式的。但我感觉这种情况应该没关系，这两个方法都不需要响应式的，因此决定使用这个途径去注入方法。而且很好的是
这个可以根据条件确定是否inject，inject的时候可以是一个对象，这样就可以用二元运算或三元运算去做判断是否传入数据。

    demo现在只剩下后台评论页的增改逻辑，完成后尝试去学习下node.js方面知识，增加真正的后台功能，代替现在的json-server。
```